/*!
 * Pad and PadUI drawpad API v0.1.0
 * http://lenkyun.tk/drawpad
 *
 * Copyright 2014 Rapeapach Suwasri
 * Released under the MIT license
 * http://lenkyun.tk/drawpad/license
 *
 * Date: 2014-08-09T15:12Z
 */
 
(function( w, $, func, require, define ){
	var error = [], msg;
	if( typeof $ === "undefined" || typeof console === "undefined" ){
		msg = "[drawpad] drawpad require jQuery to run, please set-it-up on your page.";
		error.push( msg );
		console.error( msg );
	}
	
	if( typeof w.document === "undefined" || typeof console || "undefined" ){
		msg = "[drawpad] Can't find document, please ensure that you run this script on the browser.";
		error.push( msg );
		console.error( msg );
	}
	
	if( typeof require === "undefined" && typeof define === "undefined" ){
		msg = "[drawpad] drawpad require RequireJS to run, please set-it-up on your page.";
		error.push( msg );
		console.error( msg );
		require = function(){};
		define = function(){};
	}
	
	func( w, w.document, $, $.extend, error, require, define );
	
}(typeof window !== "undefined" ? window : this, jQuery, require, define, function( window, document, $, extend, _error, require, define ){
	define('Pad/object/Settings',[],function(){		var Settings = function( obj ){				if(obj){					this.set(obj);				}				return this;			};			Settings.prototype = {			ex: {},			get: function( obj ){				if(typeof obj !== "undefined" && typeof this[obj] !== "undefined"){					return this[obj];				}				return 0;			},			create: function( obj ){				this[obj] = $.extend({}, this.ex);				return this[obj];			},			set: function( obj ){				var eventF, setF;								eventF = {					add: function( name, call ){						name = "_" + name;						if( typeof name === "undefined" ){							return false;						}						if( typeof this.event[name] !== "undefined" ){							this.event[name] = [];						}						if( typeof call !== "undefined" ){							this.event[name].push(call);						}						return true;					},					remove: function( name, call ){						var index, count = 0;						name = "_" + name;						while( (index = this.event[name].indexOf(call)) !== -1 ){							this.event[name].splice(index, 1);							count++;						}						return count;					},					run: function( name, data ){						name = "_" + name;						if( typeof event[name] === "undefined" ){							return false;						}						for( var call in event[name] ){							try{								call( data );							}catch( e ){}						}						return true;					}				};								setF = function ( a, b ){					if(typeof a !== "undefined" && a !== "event" && a !== "set"){						if(typeof b !== "undefined"){							this[a] = b;						}else{							$.extend(this, a, {event: eventF, set: setF});						}					} else {						return false;					}					return this;				};								this.ex = $.extend({}, obj, {event: eventF, set: setF});				this.ex.set = setF;				this.ex.event = eventF;				return this;			}					};				return Settings;	});

	define('Pad/object/Layer',[		"./Settings"	],function( Settings ){		// Layer - Object		// Private static zone		var indexOffset = 10;			// create settings		var setting = new Settings({				id: -1,				index: -1,				opacity: 255,				name: "Layer #-1",				width: 0,				height: 0,				DOM: {					$: false,					element: false,					context: false,					previewPad: false,					contextPad: false				}			});								// constructor		var Layer = function(index, className, width, height){			// init			var s = setting.create(this);			s.set({				id: index,				index: index,				opacity: 255,				name: "Layer #" + index,				width: width,				height: height			});						// init DOM			var canvas = $("<canvas></canvas>").attr({				"id": className + "_" + this.id,				"width": width,				"height": height			}).addClass(className);						var preview = $("<canvas></canvas>").attr({					width: width,					height: height				})[0];						s.set({				DOM: {					$: canvas,					element: canvas[0],					context: canvas[0].getContext("2d"),					previewPad: preview,					contextPad: preview.getContext("2d")				}			});						s.event.add("");						this.order(s.id);			this.opacity(255);			console.log("%c[drawpad/object/Layer] " + className + "'s layer was created.", "font-weight: bold; color: orange;");				};				// public functions and variable		Layer.prototype = {			layer: true,			// Clear canvas			clear: function(){				var s = setting.get(this); // Settings				if( s.DOM.$ ){					s.DOM.context.clearRect( 0, 0, s.width, s.height );				}				if( s.DOM.contextPad ){					s.DOM.contextPad.clearRect( 0, 0, s.width, s.height );				}					this.clearPreview();				return this;			},			order: function( i ){				var s = setting.get(this);				if( typeof i === "undefined" ){					return s.index;				}else if( i >= 0 && i < 2000 ){					s.set( "index", i );					if( s.DOM.$ ){						s.DOM.$.css( "z-index", indexOffset + s.index );					}				}				return this;			},			opacity: function( o ){				var s = setting.get(this);				if( typeof o === undefined ){					return s.opacity;				}else if( o >= 0 && o <= 255 ){					s.set( "opacity", o );					if( s.DOM.$ ){						s.DOM.$.css("opacity", o / 255);					}				} else {					console.error( "[drawpad.object.Layer] Opcaity is out of range [0-255][" + o + "]" );				}				return this;			},			name: function(name){				var s = setting.get(this);				if( typeof name === "undefined" ){					return s.name;				} else {					s.set("name", String.toString(name));					s.events.run( "nameChange", {name: name} );					return this;				}			},			getDataURL: function(){				return this.DOM.element.getDataURL();			},			remove: function(){				var e = setting.get(this).e;					this.DOM.$.remove();				$(this.DOM.previewPad).remove();				e.run("remove", {layer: this});			},			onRemove: function(e){				this.data.onDelete.push(e);			}		};				return Layer;	});

	define('Pad/object',[		"./object/Settings",		"./object/Layer"	], function(){		// ================		//   End - Object zone		// ================	});

	define('Pad/object/RGBA',[		"./Settings"	], function(Setti){		// ================		//   Core zone		// ================		// RGBA - Object		// Private static zone		var setting, RGBA;				// create settings		setting = new Setti({			value: 255		});				// constructor		RGBA = function( r, g, b, a ){			var s = setting.create( this );			if ( r && r.rgba ){				s.set( "value", r.getInt() );			} else if ( typeof r !== "undefined" && typeof g !== "undefined" && typeof b !== "undefined" && typeof a !== "undefined" ){				s.set( "value", RGBA.toInt(r, g, b, a) );			} else if ( !isNaN(r) ){				s.set( "value", r );			}		};				// static		$.extend(RGBA, {			toInt: function(r, g, b, a){				if (r.rgba){					return r.color();				} else if (isNaN(r) || isNaN(g) || isNaN(b) || isNaN(a)){					return false;				}								var color = r;				color = (color << 8) + g;				color = (color << 8) + b;				color = (color << 8) + a;				return color;			},			toRGBA: function(rgba){				return new RGBA(rgba);			},			toCSS: function(rgba){				if(!rgba && !rgba.rgba){					return false;				}				return "rgb(" + rgba.red() + ", " + rgba.green() + ", " + rgba.blue() + ")";			},			toCSSFromInt: function(rgbaInt){				var rgba = this.toRGBA(rgbaInt);				return this.toCSS(rgba);			}		});			// public function and variables		RGBA.prototype = {			rgba: true,			red: function(i){				var s = setting.get(this);				if (i !== undefined && !isNaN(i)){					if (i >= 0 && i <= 255){						var n = s.value & 0x00FFFFFF;						n = n + (i << 24);						s.set( "value", n );					} else {						console.warn("[drawpad/object/RGBA.red] Color is out of bound [0-255][%i]", i);					}				} else {					return (s.value >> 24) & 0xFF;				}			},			green: function(i){				var s = setting.get(this);				if (i !== undefined && !isNaN(i)){					if(i >= 0 && i <= 255){						var n = s.value & 0xFF00FFFF;						n = n + (i << 16);						s.set( "value", n );					}else{						console.warn("[drawpad/object/RGBA.green] Color is out of bound [0-255][%i]", i);					}				} else {					return (s.value >> 16) & 0xFF;				}			},			blue: function(i){				var s = setting.get(this);				if (i !== undefined && !isNaN(i)){					if(i >= 0 && i <= 255){						var n = s.value & 0xFFFF00FF;						n = n + (i << 8);						s.set( "value", n );					}else{						console.warn("[drawpad/object/RGBA.blue] Color is out of bound [0-255][%i]", i);					}				} else {					return (s.value >> 8) & 0xFF;				}			},			alpha: function(i){				var s = setting.get(this);				if(i !== undefined && !isNaN(i)){					if(i >= 0 && i <= 255){						var n = s.value & 0xFFFFFF00;						n = n + i;						s.set( "value", n );					}else{						console.warn("[drawpad/object/RGBA.alpha] Alpha level is out of bound [0-255][%i]", i);					}				} else {					return s.value & 0xFF;				}			},			getCSS: function(){				var s = setting.get(this);				return RGBA.toCSSFromInt(s.value);			},			getInt: function(){				var s = setting.get(this);				return s.value;			}		};				return RGBA;	});

	define('Pad/core',[		"./object/Layer",		"./object/Settings",		"./object/RGBA"	], function(Layer, Settings, RGBA){		var pad = {}, setting, style;		pad.extend = $.extend;				setting = new Settings({			TIME_DELAY: 10,			replaySpeed: 1,			CANVAS_WIDTH: 800,			CANVAS_HEIGHT: 480,			CANVAS_EVENTOFFSET: 100,			HISTORY_LIMIT: 100,			LAYERPAD_WIDTH: 150,			SAMEPOINT_LIMIT: 1,			});		setting.create(pad);			style = new Settings({			color: new RGBA(0, 0, 0, 100),			width: 20,			draw: 0, // line			layer: 0,		});		setting.style(pad);				/* Section: setting */		pad.extend({			setting: setting.get(pad).setting,			style: style.get(pad).setting 		});				setting = pad.setting;		style = pad.style;		/* End Section: setting */						pad.extend({			// Initialize the Pad			init: function(jqueLayersContainer, jqueWriteContainer){				console.groupCollapsed( "%c[drawpad.history.replay] Start init state.", "color: darkgreen; font-weight: bold" );				this.layer.root = jqueLayersContainer;				this.layer.create();				console.log( "%c[drawpad.init] Init Layer Created.", "font-weight: bold; color: darkgreen" );								// set Event				$(document).mousemove(this.mouseEvent.move);				$(window).mousedown(this.mouseEvent.down);				$(window).mouseup(this.mouseEvent.up);				console.log( "%c[drawpad.init] Events have been set.", "font-weight: bold; color: darkgreen" );					this.layer.write = new Layer(0, "drawpad-write", setting.CANVAS_WIDTH, setting.CANVAS_HEIGHT);				jqueWriteContainer.append(this.write().DOM.$);				console.log( "%c[drawpad.init] Pen layer has been set.", "font-weight: bold; color: darkgreen" );				this.layer.index(0);				console.groupEnd();			},			// Set current session style			setStyle: function(colorRGBAInt, width){				var rgba = new RGBA(colorRGBAInt);				var rgbaCSS = rgba.getCSS();					var alpha = rgba.alpha() / 255;				this.write().DOM.context.strokeStyle = rgbaCSS;				this.write().DOM.context.fillStyle = rgbaCSS;				this.write().DOM.context.lineWidth = width;				this.layer().DOM.context.globalAlpha = alpha;								style.width = width;				style.color = rgba;								this.write().opacity(rgba.alpha());			},					// Shortcut to layer.write			write: function(){				return this.layer.write;			}		});			return pad;	});

	define('Pad/pad',[		"./object",		"./core"	], function(pad){		return pad;	});

	define('drawpad',[		"./Pad/pad"	], function(){		var drawpad = {},			data = {				"Pad": undefined,				"PadUI": undefined,				"window": window,				"jQuery": $,				"document": document			}, event = {};					var get = function( str ){			if( str && data[str] ){				return data[str];			}			return false;		};					extend( event, {			ok: {				status: function(){					return _error.length === 0;				},				call: function( callback ){					callback( get );				}			},			error: {				status: function(){					return _error.length !== 0;				},				call: function( callback ){					callback( _error );				}			},		});				/*		 * Status object is similar to ./Pad/object/status		 *   @stat - status name		 */		drawpad.on = function( stat, callback ){			$(document).ready(function(){				if(typeof event[stat] !== "undefined" && event[stat].status()){					event[stat].call(callback);				}			});			return this;		};					return drawpad;	});

	window.drawpad = require("drawpad");
}));